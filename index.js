// Generated by CoffeeScript 1.10.0
(function() {
  var Promise, ajax,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  Promise = require("bluebird");

  ajax = function(options) {
    return new Promise(function(resolve, reject) {
      var complete, err, error1, key, ref, req, value;
      req = new XMLHttpRequest();
      complete = function() {
        var ref, result, successResultCodes;
        if (req.readyState === 4) {
          successResultCodes = [200, 304];
          result = JSON.parse(req.responseText);
          if (ref = req.status, indexOf.call(successResultCodes, ref) >= 0) {
            return resolve(result);
          } else {
            result.status = req.status;
            return reject(result);
          }
        }
      };
      req.addEventListener("readystatechange", complete, false);
      try {
        req.open("POST", options.url);
        req.setRequestHeader("Content-Type", "application/json");
        ref = options.headers || {};
        for (key in ref) {
          value = ref[key];
          req.setRequestHeader(key, value);
        }
        return req.send(JSON.stringify(options.payload));
      } catch (error1) {
        err = error1;
        return reject(err);
      }
    });
  };

  module.exports = function(options) {
    var headers;
    headers = options.headers || {};
    return function(dispatch, getState) {
      var error, error1, key, ref, value;
      options.headers = headers;
      ref = typeof options.getHeaders === "function" ? options.getHeaders(getState) : void 0;
      for (key in ref) {
        value = ref[key];
        options.headers[key] = value;
      }
      if ((options.onlyif == null) || options.onlyif(getState)) {
        dispatch({
          type: options.actions.request,
          payload: options.payload
        });
        try {
          return ajax(options).then(function(response) {
            return dispatch({
              response: response,
              type: options.actions.complete,
              time: new Date()
            });
          })["catch"](function(error) {
            return dispatch({
              type: options.actions.error,
              message: error
            });
          });
        } catch (error1) {
          error = error1;
          return dispatch({
            type: options.actions.error,
            message: error.message
          });
        }
      }
    };
  };

}).call(this);
